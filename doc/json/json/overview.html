<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Overview</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Boost.JSON">
<link rel="up" href="../index.html" title="Boost.JSON">
<link rel="prev" href="../index.html" title="Boost.JSON">
<link rel="next" href="usage.html" title="Usage">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="Boost.JSON Logo" width="880" height="80" src="../images/doc-logo.png"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="usage.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="json.overview"></a><a class="link" href="overview.html" title="Overview">Overview</a>
</h2></div></div></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="json.overview.introduction"></a><a class="link" href="overview.html#json.overview.introduction" title="Introduction">Introduction</a>
</h3></div></div></div>
<p>
        This library provides containers and algorithms which implement JSON (<a href="https://json.org/" target="_top">"JavaScript Object Notation"</a>),
        a lightweight data-interchange format. This format is easy for humans to
        read and write, and easy for machines to parse and generate. It is based
        on a subset of the JavaScript Programming Language, <a href="https://www.ecma-international.org/ecma-262/10.0/index.html" target="_top">Standard
        ECMA-262</a>. JSON is a text format that is language-independent but
        uses conventions that are familiar to programmers of the C-family of languages,
        including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These
        properties make JSON an ideal data-interchange language.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="json.overview.motivation"></a><a class="link" href="overview.html#json.overview.motivation" title="Motivation">Motivation</a>
</h3></div></div></div>
<p>
        Boost.JSON offers these features:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Fast compilation
          </li>
<li class="listitem">
            Require only C++11
          </li>
<li class="listitem">
            Easy and safe API with allocator support
          </li>
<li class="listitem">
            Fast incremental parser and serializer
          </li>
<li class="listitem">
            Constant-time key lookup for objects
          </li>
<li class="listitem">
            Options to allow non-standard JSON
          </li>
<li class="listitem">
            Compile without Boost, define <code class="computeroutput"><span class="identifier">BOOST_JSON_STANDALONE</span></code>
          </li>
<li class="listitem">
            Optional header-only, without linking to a library
          </li>
</ul></div>
<p>
        This library focuses on a common and popular use-case for JSON: parsing and
        serializing to and from a container called <a class="link" href="ref/boost__json__value.html" title="value"><code class="computeroutput"><span class="identifier">value</span></code></a> which holds JSON types. This
        container is designed to be well suited as a vocabulary type appropriate
        for use in public interfaces and libraries, allowing them to be composed.
        The parser and serializer are both highly performant, meeting or exceeding
        the benchmark performance of the best comparable libraries. Allocators are
        very well supported. Code which uses Boost.JSON types will be easy to read,
        flexible, and performant.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="json.overview.requirements"></a><a class="link" href="overview.html#json.overview.requirements" title="Requirements">Requirements</a>
</h3></div></div></div>
<p>
        The library relies heavily on these well known C++ types in its interfaces
        (henceforth termed <span class="emphasis"><em>standard types</em></span>):
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a class="link" href="ref/boost__json__string_view.html" title="string_view"><code class="computeroutput"><span class="identifier">string_view</span></code></a>
          </li>
<li class="listitem">
            <a class="link" href="ref/boost__json__memory_resource.html" title="memory_resource"><code class="computeroutput"><span class="identifier">memory_resource</span></code></a>,
            <a class="link" href="ref/boost__json__polymorphic_allocator.html" title="polymorphic_allocator"><code class="computeroutput"><span class="identifier">polymorphic_allocator</span></code></a>
          </li>
<li class="listitem">
            <a class="link" href="ref/boost__json__error_category.html" title="error_category"><code class="computeroutput"><span class="identifier">error_category</span></code></a>,
            <a class="link" href="ref/boost__json__error_code.html" title="error_code"><code class="computeroutput"><span class="identifier">error_code</span></code></a>,
            <a class="link" href="ref/boost__json__error_condition.html" title="error_condition"><code class="computeroutput"><span class="identifier">error_condition</span></code></a>,
            <a class="link" href="ref/boost__json__system_error.html" title="system_error"><code class="computeroutput"><span class="identifier">system_error</span></code></a>
          </li>
</ul></div>
<p>
        The requirements for Boost.JSON depend on whether the library is used as
        part of Boost, or in the standalone flavor (without Boost):
      </p>
<h5>
<a name="json.overview.requirements.h0"></a>
        <span class="phrase"><a name="json.overview.requirements.using_boost"></a></span><a class="link" href="overview.html#json.overview.requirements.using_boost">Using
        Boost</a>
      </h5>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Requires only C++11
          </li>
<li class="listitem">
            The default configuration
          </li>
<li class="listitem">
            Aliases for standard types use their Boost equivalents
          </li>
<li class="listitem">
            Link to a built static or dynamic Boost library, or use header-only (below)
          </li>
<li class="listitem">
            Supports -fno-exceptions, detected automatically
          </li>
</ul></div>
<h5>
<a name="json.overview.requirements.h1"></a>
        <span class="phrase"><a name="json.overview.requirements.without_boost"></a></span><a class="link" href="overview.html#json.overview.requirements.without_boost">Without
        Boost</a>
      </h5>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Requires C++17
          </li>
<li class="listitem">
            Aliases for standard types use their <code class="computeroutput"><span class="identifier">std</span></code>
            equivalents
          </li>
<li class="listitem">
            Obtained when defining the macro <code class="computeroutput"><span class="identifier">BOOST_JSON_STANDALONE</span></code>
          </li>
<li class="listitem">
            Link to a built static or dynamic standalone library, or use header-only
            (below)
          </li>
<li class="listitem">
            Supports -fno-exceptions: define <code class="computeroutput"><span class="identifier">BOOST_NO_EXCEPTIONS</span></code>
            and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">throw_exception</span></code> manually
          </li>
</ul></div>
<h5>
<a name="json.overview.requirements.h2"></a>
        <span class="phrase"><a name="json.overview.requirements.header_only"></a></span><a class="link" href="overview.html#json.overview.requirements.header_only">Header-Only</a>
      </h5>
<p>
        To use Boost.JSON header-only; that is, to eliminate the requirement to modify
        build scripts to link to a static or dynamic library, simply place the following
        line in any new or existing source file in your project.
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">json</span><span class="special">/</span><span class="identifier">src</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<h5>
<a name="json.overview.requirements.h3"></a>
        <span class="phrase"><a name="json.overview.requirements.embedded"></a></span><a class="link" href="overview.html#json.overview.requirements.embedded">Embedded</a>
      </h5>
<p>
        Boost.JSON works great on embedded devices. The library uses local stack
        buffers to increase the performance of some operations. On Intel platforms
        these buffers are large (4KB), while on non-Intel platforms they are small
        (256 bytes). To adjust the size of the stack buffers for embedded applications
        define this macro when building the library or including the function definitions:
      </p>
<pre class="programlisting"><span class="preprocessor">#define</span> <span class="identifier">BOOST_JSON_STACK_BUFFER_SIZE</span> <span class="number">1024</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">json</span><span class="special">/</span><span class="identifier">src</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          The library uses separate inline namespacing for the standalone flavor
          to allow libraries which use different flavors to compose without causing
          link errors. Linking to both flavors of Boost.JSON is possible, but not
          recommended.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="json.overview.supported_compilers"></a><a class="link" href="overview.html#json.overview.supported_compilers" title="Supported Compilers">Supported Compilers</a>
</h3></div></div></div>
<p>
        Boost.JSON has been tested with the following compilers:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            clang-3.8
          </li>
<li class="listitem">
            clang-4.0
          </li>
<li class="listitem">
            clang-5.0
          </li>
<li class="listitem">
            clang-6.0
          </li>
<li class="listitem">
            clang-6
          </li>
<li class="listitem">
            clang-7
          </li>
<li class="listitem">
            clang-8
          </li>
<li class="listitem">
            clang-9
          </li>
<li class="listitem">
            gcc-4.8
          </li>
<li class="listitem">
            gcc-4.9
          </li>
<li class="listitem">
            gcc-5
          </li>
<li class="listitem">
            gcc-6
          </li>
<li class="listitem">
            gcc-7
          </li>
<li class="listitem">
            gcc-8
          </li>
<li class="listitem">
            gcc-9
          </li>
<li class="listitem">
            msvc-14.1+
          </li>
</ul></div>
<h5>
<a name="json.overview.supported_compilers.h0"></a>
        <span class="phrase"><a name="json.overview.supported_compilers.quality_assurance"></a></span><a class="link" href="overview.html#json.overview.supported_compilers.quality_assurance">Quality
        Assurance</a>
      </h5>
<p>
        The development infrastructure for the library includes these per-commit
        analyses:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            coverage reports
          </li>
<li class="listitem">
            benchmark performance comparisons
          </li>
<li class="listitem">
            compilation and tests on Travis, Azure Pipelines, Appveyor
          </li>
<li class="listitem">
            fuzzing using clang-llvm and machine learning
          </li>
</ul></div>
</div>
<h4>
<a name="json.overview.h0"></a>
      <span class="phrase"><a name="json.overview.frequently_asked_questions"></a></span><a class="link" href="overview.html#json.overview.frequently_asked_questions">Frequently
      Asked Questions</a>
    </h4>
<div class="variablelist">
<p class="title"><b></b></p>
<dl class="variablelist">
<dt><span class="term"> "Isn't simdjson faster?" </span></dt>
<dd><p>
            These libraries are not comparable. The output of the simdjson parser
            is a read-only structure. In other words, it can't be changed, and the
            only way to create one is by parsing a JSON string. On the other hand,
            Boost.JSON allows you to modify the container holding the parsed JSON,
            or even build a JSON document from scratch through the container interface.
          </p></dd>
<dt><span class="term"> "I want to parse directly into my own data structures"
        </span></dt>
<dd><p>
            The purpose of this library is to enable algorithms which implement JSON
            functionality in their public interfaces to be interoperable, by providing
            a <a class="link" href="ref/boost__json__value.html" title="value"><code class="computeroutput"><span class="identifier">value</span></code></a>
            type that meets the bar for vocabulary type suitability. Parsing directly
            into a user defined type offers some advantages but is not the goal of
            the library. However, users who wish to parse directly into their own
            types may implement a custom handler for this purpose.
          </p></dd>
<dt><span class="term"> "Why not use a standard <a href="https://en.cppreference.com/w/cpp/named_req/Allocator" target="_top"><span class="emphasis"><em>Allocator</em></span></a>?"
        </span></dt>
<dd><p>
            Using standard allocators would require that <a class="link" href="ref/boost__json__value.html" title="value"><code class="computeroutput"><span class="identifier">value</span></code></a> be declared as a class
            template, which would impose an additional compilation burden. By avoiding
            the template, most of the function definitions in the library can be
            excluded from the headers and emitted in a separate static or dynamic
            library.
          </p></dd>
<dt><span class="term"> "Why use <a class="link" href="ref/boost__json__storage_ptr.html" title="storage_ptr"><code class="computeroutput"><span class="identifier">storage_ptr</span></code></a> over <a class="link" href="ref/boost__json__polymorphic_allocator.html" title="polymorphic_allocator"><code class="computeroutput"><span class="identifier">polymorphic_allocator</span></code></a>? </span></dt>
<dd><p>
            <a class="link" href="ref/boost__json__polymorphic_allocator.html" title="polymorphic_allocator"><code class="computeroutput"><span class="identifier">polymorphic_allocator</span></code></a> treats
            the memory resource as a reference with respect to ownership. Boost.JSON
            uses a reference counted smart pointer container to simplify the lifetime
            management of memory resources. In addition to being reference counted,
            <a class="link" href="ref/boost__json__storage_ptr.html" title="storage_ptr"><code class="computeroutput"><span class="identifier">storage_ptr</span></code></a>
            can function as an uncounted reference wrapper around a <a class="link" href="ref/boost__json__memory_resource.html" title="memory_resource"><code class="computeroutput"><span class="identifier">memory_resource</span></code></a>.
          </p></dd>
<dt><span class="term"> "Why <a class="link" href="ref/boost__json__string.html" title="string"><code class="computeroutput"><span class="identifier">string</span></code></a> instead of <a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_top"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code></a>?"
        </span></dt>
<dd><p>
            The string provided by the library uses the <a class="link" href="ref/boost__json__storage_ptr.html" title="storage_ptr"><code class="computeroutput"><span class="identifier">storage_ptr</span></code></a> allocator model,
            has the same interface on all C++ versions, and has an optimized class
            layout to keep the size of JSON values small. <a class="link" href="ref/boost__json__string.html" title="string"><code class="computeroutput"><span class="identifier">string</span></code></a> also implements an improved
            interface that replaces extraneous overloads with ones that use <a class="link" href="ref/boost__json__string_view.html" title="string_view"><code class="computeroutput"><span class="identifier">string_view</span></code></a>.
          </p></dd>
</dl>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="json.overview.credits"></a><a class="link" href="overview.html#json.overview.credits" title="Credits">Credits</a>
</h3></div></div></div>
<p>
        This library wouldn't be where it is today without the help of <a href="https://github.com/pdimov" target="_top">Peter
        Dimov</a> for design advice and optimization assistance.
      </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright © 2019, 2020 Vinnie Falco<br>Copyright © 2020 Krystian Stasiowski<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="usage.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
